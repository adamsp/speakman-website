<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: google-play | Adam Speakman]]></title>
  <link href="http://adamsp.github.com/speakman-website/blog/categories/google-play/atom.xml" rel="self"/>
  <link href="http://adamsp.github.com/speakman-website/"/>
  <updated>2017-10-09T16:33:25-04:00</updated>
  <id>http://adamsp.github.com/speakman-website/</id>
  <author>
    <name><![CDATA[Adam]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Implementing GCM Network Manager for periodic network requests on Android]]></title>
    <link href="http://adamsp.github.com/speakman-website/blog/2016/04/26/implementing-gcm-network-manager-for-periodic-network-requests-on-android/"/>
    <updated>2016-04-26T14:55:00-04:00</updated>
    <id>http://adamsp.github.com/speakman-website/blog/2016/04/26/implementing-gcm-network-manager-for-periodic-network-requests-on-android</id>
    <content type="html"><![CDATA[<p>In the process of rebuilding <a href="https://github.com/adamsp/wsnz-android">What's Shaking, NZ?</a>, I needed to implement a periodic network request (literally polling an API). I wanted to use the new <a href="https://developer.android.com/reference/android/app/job/JobScheduler.html">Job Scheduler</a> API, but unfortunately, this is only available on API 21 and above. Luckily we can get similar functionality by using <a href="https://developers.google.com/cloud-messaging/network-manager">GCM Network Manager</a>, as <a href="http://stackoverflow.com/q/25203254/1217087">suggested on StackOverflow</a>. Note that the GCM Network Manager actually uses Job Scheduler behind the scenes in API 21+.</p>

<p>The <a href="https://developers.google.com/cloud-messaging/network-manager">documentation</a> for this is somewhat hand-wavy. Here I attempt to provide a true step-by-step guide to implementing this. I assume you're <em>not</em> already using GCM for something else in your app (as that was the case for me).</p>

<!-- more -->


<h1>Implement GcmTaskService</h1>

<p>The first step is to import GCM in your <code>build.gradle</code>:</p>

<p><code>
compile 'com.google.android.gms:play-services-gcm:8.4.0'
</code></p>

<p>Now you can implement <a href="https://developers.google.com/android/reference/com/google/android/gms/gcm/GcmTaskService"><code>GcmTaskService</code></a>. This is as simple as the following:</p>

<p>```
import com.google.android.gms.gcm.GcmNetworkManager;
import com.google.android.gms.gcm.GcmTaskService;
import com.google.android.gms.gcm.TaskParams;</p>

<p>public class SyncService extends GcmTaskService {</p>

<pre><code>@Override
public int onRunTask(TaskParams taskParams) {
    // Perform your network request. Note you're already off the main thread here.
    return GcmNetworkManager.RESULT_SUCCESS;
}
</code></pre>

<p>}
```</p>

<p>Great. So you get a callback, on a different thread, where you can do your stuff.</p>

<h1>Add the service to the manifest</h1>

<p>The instructions say to add the service to the manifest and "Add all applicable intent filters. See details for intent filter support in the GcmTaskService API reference."</p>

<p>Note that the <a href="https://developers.google.com/android/reference/com/google/android/gms/gcm/GcmTaskService#constants">GcmTaskService documentation</a> has <code>SERVICE_ACTION_EXECUTE_TASK</code> as the name for the <code>com.google.android.gms.gcm.ACTION_TASK_READY</code> intent filter. This is right now the only thing we need to care about.</p>

<p>We also need to add the <code>RECEIVE_BOOT_COMPLETED</code> permission so that our periodic sync will persist across reboots.</p>

<p>``` xml
<uses-permission android:name="android.permission.INTERNET" />
<uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" /></p>

<p><application ... ></p>

<pre><code>&lt;service
    android:name=".SyncService"
    android:exported="true"
    android:permission="com.google.android.gms.permission.BIND_NETWORK_TASK_SERVICE"&gt;
    &lt;intent-filter&gt;
        &lt;action android:name="com.google.android.gms.gcm.ACTION_TASK_READY" /&gt;
    &lt;/intent-filter&gt;
&lt;/service&gt;
</code></pre>

<p></application>
```</p>

<h1>Schedule a persistent task</h1>

<p>You construct a <a href="https://developers.google.com/android/reference/com/google/android/gms/gcm/PeriodicTask"><code>PeriodicTask</code></a> object using a <a href="https://developers.google.com/android/reference/com/google/android/gms/gcm/PeriodicTask.Builder"><code>Builder</code></a>, and then pass that task to a <code>GcmNetworkManager</code> instance - and that's it! You can put this in your <code>SyncService</code> class and call <code>SyncService.scheduleSync(context)</code>:</p>

<p>``` java
public static void scheduleSync(Context ctx) {</p>

<pre><code>GcmNetworkManager gcmNetworkManager = GcmNetworkManager.getInstance(ctx);
PeriodicTask periodicTask = new PeriodicTask.Builder()
        .setPeriod(SYNC_PERIOD_SECONDS) // occurs at *most* once this many seconds - note that you can't control when
        .setRequiredNetwork(PeriodicTask.NETWORK_STATE_CONNECTED) // various connectivity scenarios are available
        .setTag(PERIODIC_SYNC_TAG) // returned at execution time to your endpoint
        .setService(SyncService.class) // the GcmTaskServer you created earlier
        .setPersisted(true) // persists across reboots or not
        .setUpdateCurrent(true) // replace an existing task with a matching tag - defaults to false! 
        .build();
gcmNetworkManager.schedule(periodicTask);
</code></pre>

<p>}
```</p>

<p>I've used the <a href="https://github.com/jonfinerty/Once">Once</a> library to ensure that my periodic sync is scheduled once per app install (on first launch). I just call this method from my Application class <code>onCreate</code>.</p>

<p>``` java
private void scheduleSync() {</p>

<pre><code>if (!Once.beenDone(Once.THIS_APP_INSTALL, INIT_SYNC_ON_INSTALL)) {
    SyncService.scheduleSync(this);
    Once.markDone(INIT_SYNC_ON_INSTALL);
}
</code></pre>

<p>}
```</p>

<h1>Re-schedule on app update</h1>

<p>Finally, we need to ensure that our periodic task is re-scheduled after an app update by overriding the <code>onInitializeTasks</code> method.</p>

<blockquote><p>When your package is removed or updated, all of its network tasks are cleared by the GcmNetworkManager. You can override this method to reschedule them in the case of an updated package. This is not called when your application is first installed.</p>

<p>This is called on your applicationâ€™s main thread.</p></blockquote>

<p>This is trivial enough to do:</p>

<p>``` java
@Override
public void onInitializeTasks() {</p>

<pre><code>super.onInitializeTasks();
// Re-schedule periodic task on app upgrade.
SyncService.scheduleSync(this);
</code></pre>

<p>}
```</p>

<h1>Test it</h1>

<p>You can test that your background process works by firing off the intent that triggers it:</p>

<p>``` bash
adb shell am broadcast -a "com.google.android.gms.gcm.ACTION_TRIGGER_TASK" \</p>

<pre><code>-e component speakman.whatsshakingnz/.network.SyncService \
-e tag speakman.whatsshakingnz.network.SyncService.PERIODIC_SYNC
</code></pre>

<p>```</p>

<p>Note <code>speakman.whatsshakingnz</code> is the package, and <code>.network.SyncService</code> is the component name within that package. You need to specify the tag you used earlier, too. If you've got a debugger attached you can hit a breakpoint inside your <code>onRunTask</code> method and note that you're <em>not</em> on the main thread.</p>

<h1>Gotchas</h1>

<ul>
<li>you <strong>have to reschedule on app update</strong> - this is simple enough to do, make sure you remember to do it!</li>
<li>check for Play Services! It's required for this to work.</li>
<li>if the network is unavailable/doesn't meet the criteria you specified, you can't force the task to trigger via ADB (useful to remember if you keep your test device in airplane mode!)</li>
<li>use the tags to filter out different events in the same service - <code>taskParams.getTag()</code> returns the tag that the task was created with.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Adding Google Play Services to an Android Studio project]]></title>
    <link href="http://adamsp.github.com/speakman-website/blog/2013/06/23/adding-google-play-services-to-an-android-studio-project/"/>
    <updated>2013-06-23T10:55:00-04:00</updated>
    <id>http://adamsp.github.com/speakman-website/blog/2013/06/23/adding-google-play-services-to-an-android-studio-project</id>
    <content type="html"><![CDATA[<p>Adding a support library to Android Studio is a bit different to how it's done in Eclipse. Where you'd add a 'project' in Eclipse, in Studio you add a 'Module' (which is a sub-project of your overall application - similar to Projects in a Solution, if you've done any .NET development). In this post I detail how to add the Google Play Services project, but you should be able to follow the instructions to add any support library.</p>

<!-- more -->


<p><strong>Edit July 10 2013:</strong> Note that this post only applies to projects <strong>not</strong> using Gradle.</p>

<p>Most of this information can be found on the <a href="https://developer.android.com/google/play-services/setup.html">Android Developer site</a>.</p>

<p>This guide assumes you already have an application project set up, and you're looking to add this support library in to enable new features. For setting up the main project, check out the <a href="http://developer.android.com/sdk/installing/studio.html">Android Studio documentation</a>.</p>

<ol>
<li>Update Google Play Game Services via the SDK Manager - you can launch this from <em>Tools -> Android -> SDK Manager</em>. This will download all the required files to your Android SDK install directory.</li>
<li>Copy the <code>google-play-services_lib/</code> folder (<strong>the whole folder</strong>, not just the .jar) from  <code>&lt;android-sdk&gt;/extras/google/google_play_services/libproject/google-play-services_lib/</code> to your <code>lib/</code> folder in your project.</li>
<li>In Android Studio, select <em>File -> Import Module</em>, then select the <code>google-play-services_lib</code> folder (the one you just copied into your project directory, not the one from your SDK directory).</li>
<li>Make sure 'Create module from existing sources' is selected, then Next, Next, until you reach the end of the wizard.</li>
<li>Now you have to add a reference to your new module from your existing application. Right click your existing game module (should be the top line in the Project explorer) and select <em>Open Module Settings</em>. Along the left side select <em>Modules</em> and you should see both your existing application module and your newly added library module listed. Make sure your app is selected, then choose the <em>Dependencies</em> tab. There should be a <strong>+</strong> sign at the bottom (on a Mac), or on the right side (on Windows). Click this then select <em>Module dependency</em> and add the <em>google-play-services_lib</em> module.</li>
<li>Ok, now you have everything set up correctly in your existing app module, but you need to finish setting up the one you just imported. Still in the settings window from the previous step, select the <em>google-play-services_lib</em> module under the <em>Modules</em> section. Again, click the <strong>+</strong> on the Dependencies tab but this time we're going to choose 'Jars or directories'. Navigate to the <code>google-play-services_lib/libs/</code> folder (again, the one in your application directory and not the SDK directory) and pick <em>google-play-services.jar</em>.</li>
<li>Finally, we have to make sure that other modules have access to the google-play-services.jar. In the <em>Dependencies</em> tab for the <em>google-play-services_lib</em> module, check the 'Export' checkbox for the <em>google-play-services.jar</em> entry. This makes the JAR accessible to any other module that references this one.</li>
</ol>


<p>The important part is that you import the whole project, not just the JAR file. If you only import the JAR, you don't get the associated resources. Check out this <a href="http://www.youtube.com/watch?v=nkJS_W-VC9I">Google Developers</a> video for more detail - it's the first mistake they list.</p>

<p>If you use proguard, add this to your proguard-project.txt:</p>

<pre><code>-keep class * extends java.util.ListResourceBundle {
    protected Object[][] getContents();
}
</code></pre>

<p>You can confirm that it's worked by building the project (you may need to do a <em>Build -> Rebuild Project</em>) and making sure there's no errors. To see the imported module in the Project explorer, switch the drop down at the top of the Project explorer to 'Packages' instead of 'Project'.</p>

<p>If you're adding a project other than Google Play Services, such as <a href="http://actionbarsherlock.com/">ActionBarSherlock</a>, that project may use the Android support library. If you're using this too (as is likely) you need to ensure you only have one support library JAR referenced. You should export the JAR from the library (as in step 7 above) and then delete the one in your own module.</p>
]]></content>
  </entry>
  
</feed>
