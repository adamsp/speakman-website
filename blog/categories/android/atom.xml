<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: android | Adam Speakman]]></title>
  <link href="http://adamsp.github.com/speakman-website/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://adamsp.github.com/speakman-website/"/>
  <updated>2017-10-09T16:33:25-04:00</updated>
  <id>http://adamsp.github.com/speakman-website/</id>
  <author>
    <name><![CDATA[Adam]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Asynchronously loading data using Googles Paging Library]]></title>
    <link href="http://adamsp.github.com/speakman-website/blog/2017/10/09/asynchronously-loading-data-using-googles-paging-library/"/>
    <updated>2017-10-09T14:42:00-04:00</updated>
    <id>http://adamsp.github.com/speakman-website/blog/2017/10/09/asynchronously-loading-data-using-googles-paging-library</id>
    <content type="html"><![CDATA[<p>The recently released <a href="https://developer.android.com/topic/libraries/architecture/paging.html">Paging Library</a> from Google gives you an easy way to page data into memory off of the main thread. If you want to use it with <a href="https://developer.android.com/topic/libraries/architecture/room.html">Room</a>, then the built-in support makes it trivial. However, if you'd like to page data that exists elsewhere - from the network or disk, for example - then you have to do a little extra work.</p>

<p>Here I demonstrate how to take existing code that loads a list of screenshots from disk and convert it to load asynchronously using the Paging Library. This example could easily be adapted for network calls.</p>

<!-- more -->


<p>Throughout this post we'll be using a <code>Screenshot</code> class defined as follows:</p>

<p><code>kotlin
@Parcelize
class Screenshot(val uri: Uri, val width: Int, val height: Int) : Parcelable
</code></p>

<p>You will also need to import the library:</p>

<p><code>
implementation "android.arch.paging:runtime:1.0.0-alpha2"
</code></p>

<h2>Existing code</h2>

<p>When the app launches, it shows the user a list of images from a directory they supply during setup. My existing code was a simple repository that loaded <em>all</em> screenshots (as a Uri and width/height values) from this directory via Android's storage access framework. The code was similar to the following:</p>

<p>``` kotlin
override fun allScreenshots(): List<Screenshot> {</p>

<pre><code>val screenshots = documentsAtUri(screenshotDirectory)
return screenshots.map {
    getScreenshotFromUri(DocumentsContract.buildDocumentUriUsingTree(it.path, it.id))
}
</code></pre>

<p>}</p>

<p>private fun getScreenshotFromUri(uri: Uri): Screenshot {</p>

<pre><code>val (width, height) = getDimens(uri)
return Screenshot(uri, width, height)
</code></pre>

<p>}</p>

<p>private fun getDimens(uri: Uri): Pair&lt;Int, Int> {</p>

<pre><code>val opts = BitmapFactory.Options()
opts.inJustDecodeBounds = true
val parcelFileDescriptor = contentResolver.openFileDescriptor(uri, "r")
val fileDescriptor = parcelFileDescriptor!!.fileDescriptor
BitmapFactory.decodeFileDescriptor(fileDescriptor, null, opts)
return Pair(opts.outWidth, opts.outHeight)
</code></pre>

<p>}
```</p>

<p>As you can see, we have to go to disk to get information about every screenshot. This is expensive! On my test device I've only got around 100 screenshots - on a device that's been around longer a user could have many hundreds or thousands of screenshots in this folder. Rather than loading these all up front, I need to load these asynchronously. In addition, since these are in a list there's a high likelihood that the items further down the list won't even be needed. The Paging Library helps with these problems.</p>

<h2>Paging Library Fundamentals</h2>

<p>The Paging Library has 3 different "levels" that build on top of each other.</p>

<p>At the base, we have a kind of <a href="https://developer.android.com/reference/android/arch/paging/DataSource.html"><code>DataSource</code></a>. This can be either "keyed" (such that you need to know about the item at index N-1 in order to know about the item at index N - like a linked list), or "tiled" (such that you can access elements at arbitray indices - like an array list).</p>

<p>Above that, we have a <a href="https://developer.android.com/reference/android/arch/paging/PagedList.html"><code>PagedList</code></a>, which as its name suggests, is a list that pages its data in from a <code>DataSource</code>.</p>

<p>Finally we have the <a href="https://developer.android.com/reference/android/arch/paging/PagedListAdapter.html"><code>PagedListAdapter</code></a>, which is a <code>RecyclerView.Adapter</code> that neatly wraps a <code>PagedList</code>, calling the correct <code>notifyItem...</code> methods for you as your data changes (when you call <code>setList</code> with a new <code>PagedList</code>) or loads in. This is fairly standard <code>RecyclerView</code> boilerplate. If you need some custom behaviour, you can duplicate its functionality - it's just a handy wrapper around the <a href="https://developer.android.com/reference/android/arch/paging/PagedListAdapterHelper.html"><code>PagedListAdapterHelper</code></a>.</p>

<h2>Constructing a Data Source</h2>

<p>A <code>DataSource</code> is reasonably simple. For a list like this, we implement a <code>TiledDataSource</code>, doing the expensive disk IO in the <code>loadRange</code> method. The <code>PagedList</code> will call this from a background thread when it is time to load a new page of data.</p>

<p>Note that it does <em>not</em> clamp ranges for you - so if you have 10 items and a page size of 6, your second page will be <code>startPosition = 6</code> and <code>count = 6</code> - which will give you an <code>IndexOutOfBoundsException</code>. Make sure to clamp your inputs as I do here.</p>

<p>``` kotlin
val screenshots = documentsAtUri(loadScreenshotDirectory())</p>

<p>val dataSource: DataSource&lt;Int, Screenshot> = object : TiledDataSource<Screenshot>() {</p>

<pre><code>override fun countItems(): Int {
    return screenshots.size
}

override fun loadRange(startPosition: Int, count: Int): List&lt;Screenshot&gt; {
    val end = minOf(startPosition + count, countItems())
    return screenshots.subList(startPosition, end).map {
        getScreenshot(DocumentsContract.buildDocumentUriUsingTree(it.path, it.id))
    }
}
</code></pre>

<p>}
```</p>

<h2>Building a Paged List</h2>

<p>For my use-case, 8 elements on a 'page' was sufficient. I'm showing elements in a 2-column list; most of the elements are around half the window height. You'll need to decide what works well for you.</p>

<p>Note that here we use the default prefetch distance of <code>pageSize</code> - that is, as soon as the first item in a given page of data is requested, the next page will begin loading. Depending on your data, you may want this to be smaller or larger.</p>

<p>We also enable placeholders (this is actually enabled by default). Since we know exactly how many elements are going to be in our list (we have Uris for every screenshot, even if we don't have any details about that screenshot yet) we can use null placeholders while the images load - helping avoid weird scrollbars. Our <code>onBindViewHolder</code> has to deal with this later. I'd recommend <a href="https://developer.android.com/reference/android/arch/paging/PagedList.html">reading the <code>PagedList</code> docs</a> - they go into more detail on placeholders.</p>

<p>You need to supply two <a href="https://developer.android.com/reference/java/util/concurrent/Executor.html"><code>Executor</code></a>s - one for posting back to the main thread, and another for background work. In this example we create a main thread <code>Handler</code> and post events to it directly, but our disk IO <code>Executor</code> is injected from elsewhere.</p>

<p>Finally, this code has one subtle gotcha - the first two pages will be loaded immediately on whatever thread <code>build()</code> is called from! From the docs:</p>

<blockquote><p>Creating a PagedList loads data from the DataSource immediately, and should for this reason be done on a background thread. The constructed PagedList may then be passed to and used on the UI thread. This is done to prevent passing a list with no loaded content to the UI thread, which should generally not be presented to the user.</p></blockquote>

<p>In this case, we'll be going to disk 16 times (8 for the first page, and then another 8 as the second page is pre-fetched). I address this later when I wire everything together.</p>

<p>``` kotlin
val mainHandler = Handler(Looper.getMainLooper())</p>

<p>val pagedList = PagedList.Builder&lt;Int, Screenshot>()</p>

<pre><code>.setDataSource(dataSource)
.setMainThreadExecutor({ mainHandler.post(it) })
.setBackgroundThreadExecutor(diskExecutor)
.setConfig(PagedList.Config.Builder()
        .setPageSize(8)
        .setEnablePlaceholders(true)
        .build())
.build()
</code></pre>

<p>```</p>

<h2>Adding the Adapter</h2>

<p>The simplest part of all. We just extend <code>PagedListAdapter</code>, supplying a simple <code>DiffCallback</code> for comparing <code>Screenshot</code> objects, and implement <code>onBindViewHolder</code> and <code>onCreateViewHolder</code> like normal.</p>

<p>Note if you have custom logic (such as a custom <code>BindingAdapter</code> - not shown here) you need to be aware that the object returned from <code>getItem</code> <em>can be</em> <code>null</code> - these are the placeholders we enabled earlier, and will be <code>null</code> while the data at that index loads. If your page sizes are appropriate, receiving a <code>null</code> object will be rare, but you <em>must</em> handle it.</p>

<p>``` kotlin ScreenshotPickerAdapter.kt
val DIFF_CALLBACK = object : DiffCallback<Screenshot>() {</p>

<pre><code>override fun areItemsTheSame(oldItem: Screenshot, newItem: Screenshot): Boolean {
    return oldItem.uri == newItem.uri
}

override fun areContentsTheSame(oldItem: Screenshot, newItem: Screenshot): Boolean {
    return oldItem.uri == newItem.uri
}
</code></pre>

<p>}</p>

<p>class ScreenshotPickerAdapter(val clickHandler: ScreenshotPickerSelectionHandler)</p>

<pre><code>: PagedListAdapter&lt;Screenshot, ScreenshotViewHolder&gt;(DIFF_CALLBACK) {

override fun onBindViewHolder(holder: ScreenshotViewHolder, position: Int) {
    val screenshot = getItem(position)
    holder.screenshot = screenshot
}

override fun onCreateViewHolder(parent: ViewGroup?, viewType: Int): ScreenshotViewHolder {
    val binding: PickerListItemBinding = DataBindingUtil.inflate(
        LayoutInflater.from(parent?.context), R.layout.picker_list_item, parent, false)
    return ScreenshotViewHolder(binding, clickHandler)
}
</code></pre>

<p>}
```</p>

<h2>Wiring it all up</h2>

<p>Now we have all the pieces we can put them together. Note that I supply an async callback for loading the screenshots - we use the disk executor we supply in the constructor to do the actual building (since this loads the first page or more, as mentioned above!) and then set the result on our list once that load has finished.</p>

<p>For brevity, this code doesn't consider configuration changes or other kinds of activity destruction.</p>

<p><code>kotlin Executors.kt
// Define a disk IO executor that can be re-used elsewhere
val diskExecutor = Executors.newFixedThreadPool(2)
</code></p>

<p>``` kotlin MainActivity.kt
var screenshotLoader: ScreenshotLoader? = null
var adapter: ScreenshotPickerAdapter? = null</p>

<p>override fun onCreate(savedInstanceState: Bundle?) {</p>

<pre><code>super.onCreate(savedInstanceState)
setContentView(R.layout.activity_main)
screenshotLoader = SAFScreenshotLoader(contentResolver, diskExecutor)
adapter = ScreenshotPickerAdapter(this)
val recycler = findViewById(R.id.main_recycler) as RecyclerView?
recycler?.layoutManager = GridLayoutManager(this, 2)
recycler?.adapter = adapter
loadScreenshots()
</code></pre>

<p>}</p>

<p>private fun loadScreenshots() {</p>

<pre><code>screenshotLoader?.allScreenshots({
    // We could explode here if the activity has been killed
    runOnUiThread {
        adapter?.setList(it)
    }
})
</code></pre>

<p>}
```</p>

<p>``` kotlin SAFScreenshotLoader.kt
override fun allScreenshots(resultListener: (PagedList<Screenshot>) -> Unit) {</p>

<pre><code>// This assumes retrieving the Uris is cheap - this whole block could be moved off thread
val screenshotUris = documentsAtUri(loadScreenshotDirectory())
val dataSource: DataSource&lt;Int, Screenshot&gt; = object : TiledDataSource&lt;Screenshot&gt;() {
    override fun countItems(): Int {
        return screenshotUris.size
    }

    override fun loadRange(startPosition: Int, count: Int): List&lt;Screenshot&gt; {
        val end = minOf(startPosition + count, countItems())
        return screenshotUris.subList(startPosition, end).map {
            getScreenshot(DocumentsContract.buildDocumentUriUsingTree(it.path, it.id))
        }
    }
}
val builder = PagedList.Builder&lt;Int, Screenshot&gt;()
        .setDataSource(dataSource)
        .setMainThreadExecutor({ mainHandler.post(it) })
        .setBackgroundThreadExecutor(diskExecutor)
        .setConfig(PagedList.Config.Builder()
                .setPageSize(8)
                .setEnablePlaceholders(true)
                .build())
// Note the actual construction happens on an IO thread - the build() call goes to disk
diskExecutor.execute {
    resultListener(builder.build())
}
</code></pre>

<p>}
```</p>

<h2>Gotchas</h2>

<ul>
<li>You may have to specify a <code>minHeight</code> on your list items, or otherwise specify the height when a placeholder is used. If you don't, the adapter will query for (and the list will try to load) your whole list of 0-height items.</li>
<li>Don't forget the first page is loaded when you call <code>PagedList.Builder.build()</code> - do this off the main thread!</li>
<li>Experiment with page sizes and prefetch windows. This is entirely dependent on your data.</li>
<li>Already loaded objects are <strong>not</strong> unloaded. If the user scrolls to the bottom of the list, the first items stay in memory. This is potentially a problem if your objects are large, or your list is long. Here I let <a href="http://square.github.io/picasso/">Picasso</a> load (and unload) the actual memory-intensive bitmaps for me. Storing a list of Uris is cheap.</li>
<li>You <strong>must</strong> handle null objects returned from <code>getItem</code> if you enable placeholders, even if you never encounter them in your testing.</li>
<li>The <code>loadRange</code> call is not bounded to the size of the list; you need to do this yourself. It will happily handle results smaller than the requested count, however (i.e. when you're at the end of the list).</li>
<li>If you're using <a href="https://developer.android.com/reference/android/arch/lifecycle/LiveData.html"><code>LiveData</code></a>, look into <a href="https://developer.android.com/reference/android/arch/paging/LivePagedListProvider.html"><code>LivePagedListProvider</code></a> as it will do most of this overhead for you.</li>
<li>The library is still in alpha at the time of this writing; the APIs described here could still change before release.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Implementing GCM Network Manager for periodic network requests on Android]]></title>
    <link href="http://adamsp.github.com/speakman-website/blog/2016/04/26/implementing-gcm-network-manager-for-periodic-network-requests-on-android/"/>
    <updated>2016-04-26T14:55:00-04:00</updated>
    <id>http://adamsp.github.com/speakman-website/blog/2016/04/26/implementing-gcm-network-manager-for-periodic-network-requests-on-android</id>
    <content type="html"><![CDATA[<p>In the process of rebuilding <a href="https://github.com/adamsp/wsnz-android">What's Shaking, NZ?</a>, I needed to implement a periodic network request (literally polling an API). I wanted to use the new <a href="https://developer.android.com/reference/android/app/job/JobScheduler.html">Job Scheduler</a> API, but unfortunately, this is only available on API 21 and above. Luckily we can get similar functionality by using <a href="https://developers.google.com/cloud-messaging/network-manager">GCM Network Manager</a>, as <a href="http://stackoverflow.com/q/25203254/1217087">suggested on StackOverflow</a>. Note that the GCM Network Manager actually uses Job Scheduler behind the scenes in API 21+.</p>

<p>The <a href="https://developers.google.com/cloud-messaging/network-manager">documentation</a> for this is somewhat hand-wavy. Here I attempt to provide a true step-by-step guide to implementing this. I assume you're <em>not</em> already using GCM for something else in your app (as that was the case for me).</p>

<!-- more -->


<h1>Implement GcmTaskService</h1>

<p>The first step is to import GCM in your <code>build.gradle</code>:</p>

<p><code>
compile 'com.google.android.gms:play-services-gcm:8.4.0'
</code></p>

<p>Now you can implement <a href="https://developers.google.com/android/reference/com/google/android/gms/gcm/GcmTaskService"><code>GcmTaskService</code></a>. This is as simple as the following:</p>

<p>```
import com.google.android.gms.gcm.GcmNetworkManager;
import com.google.android.gms.gcm.GcmTaskService;
import com.google.android.gms.gcm.TaskParams;</p>

<p>public class SyncService extends GcmTaskService {</p>

<pre><code>@Override
public int onRunTask(TaskParams taskParams) {
    // Perform your network request. Note you're already off the main thread here.
    return GcmNetworkManager.RESULT_SUCCESS;
}
</code></pre>

<p>}
```</p>

<p>Great. So you get a callback, on a different thread, where you can do your stuff.</p>

<h1>Add the service to the manifest</h1>

<p>The instructions say to add the service to the manifest and "Add all applicable intent filters. See details for intent filter support in the GcmTaskService API reference."</p>

<p>Note that the <a href="https://developers.google.com/android/reference/com/google/android/gms/gcm/GcmTaskService#constants">GcmTaskService documentation</a> has <code>SERVICE_ACTION_EXECUTE_TASK</code> as the name for the <code>com.google.android.gms.gcm.ACTION_TASK_READY</code> intent filter. This is right now the only thing we need to care about.</p>

<p>We also need to add the <code>RECEIVE_BOOT_COMPLETED</code> permission so that our periodic sync will persist across reboots.</p>

<p>``` xml
<uses-permission android:name="android.permission.INTERNET" />
<uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" /></p>

<p><application ... ></p>

<pre><code>&lt;service
    android:name=".SyncService"
    android:exported="true"
    android:permission="com.google.android.gms.permission.BIND_NETWORK_TASK_SERVICE"&gt;
    &lt;intent-filter&gt;
        &lt;action android:name="com.google.android.gms.gcm.ACTION_TASK_READY" /&gt;
    &lt;/intent-filter&gt;
&lt;/service&gt;
</code></pre>

<p></application>
```</p>

<h1>Schedule a persistent task</h1>

<p>You construct a <a href="https://developers.google.com/android/reference/com/google/android/gms/gcm/PeriodicTask"><code>PeriodicTask</code></a> object using a <a href="https://developers.google.com/android/reference/com/google/android/gms/gcm/PeriodicTask.Builder"><code>Builder</code></a>, and then pass that task to a <code>GcmNetworkManager</code> instance - and that's it! You can put this in your <code>SyncService</code> class and call <code>SyncService.scheduleSync(context)</code>:</p>

<p>``` java
public static void scheduleSync(Context ctx) {</p>

<pre><code>GcmNetworkManager gcmNetworkManager = GcmNetworkManager.getInstance(ctx);
PeriodicTask periodicTask = new PeriodicTask.Builder()
        .setPeriod(SYNC_PERIOD_SECONDS) // occurs at *most* once this many seconds - note that you can't control when
        .setRequiredNetwork(PeriodicTask.NETWORK_STATE_CONNECTED) // various connectivity scenarios are available
        .setTag(PERIODIC_SYNC_TAG) // returned at execution time to your endpoint
        .setService(SyncService.class) // the GcmTaskServer you created earlier
        .setPersisted(true) // persists across reboots or not
        .setUpdateCurrent(true) // replace an existing task with a matching tag - defaults to false! 
        .build();
gcmNetworkManager.schedule(periodicTask);
</code></pre>

<p>}
```</p>

<p>I've used the <a href="https://github.com/jonfinerty/Once">Once</a> library to ensure that my periodic sync is scheduled once per app install (on first launch). I just call this method from my Application class <code>onCreate</code>.</p>

<p>``` java
private void scheduleSync() {</p>

<pre><code>if (!Once.beenDone(Once.THIS_APP_INSTALL, INIT_SYNC_ON_INSTALL)) {
    SyncService.scheduleSync(this);
    Once.markDone(INIT_SYNC_ON_INSTALL);
}
</code></pre>

<p>}
```</p>

<h1>Re-schedule on app update</h1>

<p>Finally, we need to ensure that our periodic task is re-scheduled after an app update by overriding the <code>onInitializeTasks</code> method.</p>

<blockquote><p>When your package is removed or updated, all of its network tasks are cleared by the GcmNetworkManager. You can override this method to reschedule them in the case of an updated package. This is not called when your application is first installed.</p>

<p>This is called on your application’s main thread.</p></blockquote>

<p>This is trivial enough to do:</p>

<p>``` java
@Override
public void onInitializeTasks() {</p>

<pre><code>super.onInitializeTasks();
// Re-schedule periodic task on app upgrade.
SyncService.scheduleSync(this);
</code></pre>

<p>}
```</p>

<h1>Test it</h1>

<p>You can test that your background process works by firing off the intent that triggers it:</p>

<p>``` bash
adb shell am broadcast -a "com.google.android.gms.gcm.ACTION_TRIGGER_TASK" \</p>

<pre><code>-e component speakman.whatsshakingnz/.network.SyncService \
-e tag speakman.whatsshakingnz.network.SyncService.PERIODIC_SYNC
</code></pre>

<p>```</p>

<p>Note <code>speakman.whatsshakingnz</code> is the package, and <code>.network.SyncService</code> is the component name within that package. You need to specify the tag you used earlier, too. If you've got a debugger attached you can hit a breakpoint inside your <code>onRunTask</code> method and note that you're <em>not</em> on the main thread.</p>

<h1>Gotchas</h1>

<ul>
<li>you <strong>have to reschedule on app update</strong> - this is simple enough to do, make sure you remember to do it!</li>
<li>check for Play Services! It's required for this to work.</li>
<li>if the network is unavailable/doesn't meet the criteria you specified, you can't force the task to trigger via ADB (useful to remember if you keep your test device in airplane mode!)</li>
<li>use the tags to filter out different events in the same service - <code>taskParams.getTag()</code> returns the tag that the task was created with.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Handling RealmMigrationNeededException on a fresh installation on Android]]></title>
    <link href="http://adamsp.github.com/speakman-website/blog/2016/04/21/handling-realmmigrationneededexception-on-a-fresh-installation-on-android/"/>
    <updated>2016-04-21T18:33:00-04:00</updated>
    <id>http://adamsp.github.com/speakman-website/blog/2016/04/21/handling-realmmigrationneededexception-on-a-fresh-installation-on-android</id>
    <content type="html"><![CDATA[<p>Back in November, I had just started using <a href="https://realm.io/">Realm</a> on Android and was having some troubles. I'd occasionally need to make a model change, and being early on in development I was happy to just delete the Realm and start again - in production you'd want to perform a migration so you don't lose any user data.</p>

<p>However, the "delete and re-install" approach wasn't working as expected - I kept getting a <code>RealmMigrationNeededException</code>:</p>

<p><code>
io.realm.exceptions.RealmMigrationNeededException: RealmMigration must be provided
</code></p>

<p>This doesn't make sense! I should be able to uninstall an app and upon reinstalling it I should have a fresh slate to work with. As it turns out, not quite. I couldn't figure out why at the time, but <a href="https://github.com/realm/realm-java/issues/1856">the workaround</a> was to simply add a <code>deleteRealmMigrationIfNeeded()</code> call to my Realm configuration when building it. I made a note to deal with this before release, and carried on my way.</p>

<!-- more -->


<p>This morning I was getting ready to publish and Lint warned me that I didn't handle <a href="http://developer.android.com/intl/es/training/backup/autosyncapi.html">Android 6.0 Marshmallow automatic backup</a>. After some investigation, I realised that this was backing up and restoring my Realm files! The order of operations which caused the above issue was:</p>

<ol>
<li>app backup occurs</li>
<li>uninstall app</li>
<li>install app (ie launching from Android Studio)</li>
<li>restore backup (note before the app launches!)</li>
<li>continue launching app</li>
</ol>


<p>It seemed simple enough to handle - I'd just exclude the <code>default.realm</code> and <code>default.realm.lock</code> files from backup and it'd work. Unfortunately this still backs up the Realm log files, all preference files (plenty of third party libraries make use of shared prefs) and even files related to instant-run! This makes a "clean install" not quite what you'd expect - not clean at all.</p>

<p>My recommendation is to explicitly <em>include</em> only the things you want. For example, I only care about my users settings - I can re-retrieve everything else remotely - so my <code>xml/backup.xml</code> looks like this:</p>

<p>``` xml
&lt;?xml version="1.0" encoding="utf-8"?>
<full-backup-content></p>

<pre><code>&lt;include domain="sharedpref" path="speakman.whatsshakingnz_preferences.xml"/&gt;
</code></pre>

<p></full-backup-content>
```</p>

<p>You also need to reference this file in your manifest:</p>

<p>``` xml
<manifest ... ></p>

<pre><code>&lt;application ...
    android:fullBackupContent="@xml/backup"&gt;
    ...
</code></pre>

<p></manifest>
```</p>

<p>Note that you <a href="http://stackoverflow.com/q/36773020/1217087">must specify the <code>.xml</code> extension</a> when backing up shared preferences files - this is an implementation detail we unfortunately have to worry about, which is a bit strange, especially as we both specify a domain for the file and do <em>not</em> specify the file extension in code.</p>

<p>If you're having trouble with this, I'd also recommend <a href="http://stackoverflow.com/q/33743941/1217087">reading through this StackOverflow question &amp; answer</a>, as following through this helped a lot with figuring out what was going on.</p>

<p>Finally, the last useful bit of info I have is how to <em>wipe</em> a backup. You <em>must have the app installed</em>, and then you can wipe the existing server-side backup with:</p>

<p><code>
adb shell bmgr wipe com.google.android.gms/.backup.BackupTransportService com.yourpackage
</code></p>

<p>Note that the <code>BackupTransportService</code> part refers to the default transport for backup - you should check what yours is by running <code>adb shell bmgr list transports</code> - the default will be marked with a <code>*</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A bug in (and a fix for) the way FragmentStatePagerAdapter handles fragment restoration]]></title>
    <link href="http://adamsp.github.com/speakman-website/blog/2014/02/20/a-bug-in-and-a-fix-for-the-way-fragmentstatepageradapter-handles-fragment-restoration/"/>
    <updated>2014-02-20T21:25:00-05:00</updated>
    <id>http://adamsp.github.com/speakman-website/blog/2014/02/20/a-bug-in-and-a-fix-for-the-way-fragmentstatepageradapter-handles-fragment-restoration</id>
    <content type="html"><![CDATA[<p>Ever used a <a href="https://developer.android.com/reference/android/support/v4/app/FragmentStatePagerAdapter.html"><code>FragmentStatePagerAdapter</code></a>? We're using one at work for our ticket purchasing wizard. The user enters the wizard, and can progress to the next page once they've completed the current one. We control this by manipulating the stack of pages and notifying the adapter that the data has changed when a new page is available.</p>

<p>Unfortunately, when changing pages that have already been loaded, there's an unexpected bug. Specifically, when you load a page, remove it and then insert a new one in its place, the next time the fragment at that index is loaded, it receives the <code>savedInstanceState</code> bundle for the <em>old</em> fragment.</p>

<!-- more -->


<h1>How'd you find <em>that</em>?</h1>

<p>The specific use case where I discovered this was the case where a customer is purchasing tickets to a film, and they change their mind about which type of tickets they want.</p>

<p>First, the customer selects tickets that require manually selected seats. We save the tickets, receive the seating data, and send the customer to the next page where they can select from a seat in a map.</p>

<p>If the customer changes their mind at this stage and returns to the previous page, as soon as they make a change to their selected tickets we consider all future pages invalid. We 'remove' the seat selection fragment and notify the adapter. If the customer has now selected tickets that <em>don't</em> require manual seat selection (that is, they've chosen tickets for an unallocated seating area), we save the tickets, receive empty seating data, and know to send them on to the "details" page where they can enter in their name and email.</p>

<p>This is where the process breaks down. Since the two fragments are different (one's called <code>SeatingFragment</code> and the other is <code>CustomerDetailsFragment</code>, say), I wasn't expecting to receive any saved instance state on the first load of the new fragment - however I was getting state passed in! This caused a crash, as I was depending on the state being null to assume first-load.</p>

<p>The state I was seeing was the state for the previously loaded fragment at that index. That is, when the <code>CustomerDetailsFragment</code> in the example scenario was loaded (replacing the <code>SeatingFragment</code>), it was receiving the saved state bundle for the <code>SeatingFragment</code>, when it should've been receiving no saved state bundle at all.</p>

<h1>Can you reproduce it?</h1>

<p>I've written a <a href="https://github.com/adamsp/FragmentStatePagerIssueExample">very simple example app</a> which shows this behaviour. If you swipe backwards and forwards you can see the fragments labeled "1", "2", "3", colored Red, Yellow and Green. Now, press the 'Switch Fragment' button. You'll be sent back to index 0 (fragment "1"). This forces the removal of fragment "3", which gets its state saved. But we've changed the content of the adapter - so next time you load fragment "3", you'll see that its color has changed to Blue. <strong>This is a different fragment</strong>, but it's label has been restored from the previous fragments saved state! If you rotate your device, or simply swipe back to the first view and then back to the third again, you'll see the correct label of "4" (it saves the state fresh when it removes it, resulting in the correct saved state next time it's loaded).</p>

<h1>Why does this occur?</h1>

<p>If we take a look at the source code <a href="https://android.googlesource.com/platform/frameworks/support/+/6d6186b9a2503200844febe1b8ba083206c7cbcd/v4/java/android/support/v4/app/FragmentStatePagerAdapter.java">as of this writing</a>, we can see that the <code>FragmentStatePagerAdapter</code> stores a list of states:</p>

<p><code>
private ArrayList&lt;Fragment.SavedState&gt; mSavedState = new ArrayList&lt;Fragment.SavedState&gt;();
</code></p>

<p>Looking through the code we can see that this array is used in four places. It's used in <code>instantiateItem</code>, <code>destroyItem</code>, <code>saveState</code> and <code>restoreState</code>.  We can ignore <code>saveState</code> and <code>restoreState</code> for now, as they're just saving the adapters overall state into an external bundle, and then loading it back up.</p>

<p>First, let's take a look at what's going on in <code>destroyItem</code>. When a fragment is due to be destroyed, this method first starts a transaction (if one isn't already started), then pads out the <code>mSavedState</code> array with null entries until it's at least the size of the index of the fragment we're removing.</p>

<p>```</p>

<pre><code>@Override
public void destroyItem(ViewGroup container, int position, Object object) {
    Fragment fragment = (Fragment)object;

    if (mCurTransaction == null) {
        mCurTransaction = mFragmentManager.beginTransaction();
    }
    if (DEBUG) Log.v(TAG, "Removing item #" + position + ": f=" + object
            + " v=" + ((Fragment)object).getView());
    while (mSavedState.size() &lt;= position) {
        mSavedState.add(null);
    }
</code></pre>

<p>```</p>

<p>Nothing too exciting there. It then saves the state of the fragment that is being removed into the corresponding index in the <code>mSavedState</code> list, and removes the fragment:</p>

<p>```</p>

<pre><code>    mSavedState.set(position, mFragmentManager.saveFragmentInstanceState(fragment));
    mFragments.set(position, null);

    mCurTransaction.remove(fragment);
}
</code></pre>

<p>```</p>

<p>Now let's see what happens in the other direction - instantiating an item. First thing to do is check and see if we already have a <code>Fragment</code> object created and stored at the given position. Short-circuit back out with this if we do:</p>

<p>```</p>

<pre><code>@Override
public Object instantiateItem(ViewGroup container, int position) {
    // If we already have this item instantiated, there is nothing
    // to do.  This can happen when we are restoring the entire pager
    // from its saved state, where the fragment manager has already
    // taken care of restoring the fragments we previously had instantiated.
    if (mFragments.size() &gt; position) {
        Fragment f = mFragments.get(position);
        if (f != null) {
            return f;
        }
    }
</code></pre>

<p>```</p>

<p>If however we <em>don't</em> have a fragment there, we have to create one. This could be because we've never seen this page of the <code>ViewPager</code> before, or it could be because the page was removed due to the left/right limits (recall a <code>ViewPager</code> will only keep the first page to the left and right of the current one, by default).</p>

<p>```</p>

<pre><code>    if (mCurTransaction == null) {
        mCurTransaction = mFragmentManager.beginTransaction();
    }

    Fragment fragment = getItem(position);
    if (DEBUG) Log.v(TAG, "Adding item #" + position + ": f=" + fragment);
</code></pre>

<p>```</p>

<p>Now, here's the important part. After we've asked our concrete subclass to create/instantiate a fragment for us (through the <code>getItem(position)</code> call), we check to see if we have any saved state <em>at that position</em>. There's the crucial part - we're <strong>checking for saved state based on the fragments index in an array, rather than on some unique property of the fragment</strong>.</p>

<p>```</p>

<pre><code>    if (mSavedState.size() &gt; position) {
        Fragment.SavedState fss = mSavedState.get(position);
        if (fss != null) {
            fragment.setInitialSavedState(fss);
        }
    }
</code></pre>

<p>```</p>

<p>The issue with this is that the fragment at that position may no longer be the same fragment as was there last time we displayed the page at this position! So that saved state bundle may no longer be the correct one.</p>

<p>Finally, we add the fragment to our list of fragments and display it:</p>

<p>```</p>

<pre><code>    while (mFragments.size() &lt;= position) {
        mFragments.add(null);
    }
    fragment.setMenuVisibility(false);
    fragment.setUserVisibleHint(false);
    mFragments.set(position, fragment);
    mCurTransaction.add(container.getId(), fragment);

    return fragment;
}
</code></pre>

<p>```</p>

<h1>Fixes or workarounds?</h1>

<p>Luckily, there's a way around this problem! Hurrah!</p>

<p>We simply need some way of identifying the fragments, and comparing whether this identifying value is the same or not when we try to restore state to a freshly instantiated fragment. The best way to do this is to ask our concrete subclass for an identifier for this fragment - a tag.</p>

<p>So, let's copy the <a href="https://android.googlesource.com/platform/frameworks/support/+/master/v4/java/android/support/v4/app/FragmentStatePagerAdapter.java">entire source of <code>FragmentStatePagerAdapter</code></a> and get started. First thing to do is add a way of getting tags from our subclasses. Since we don't want to break existing implementations that don't actually care about swapping out fragments, we won't make this method abstract. Instead it'll just <code>return null;</code> by default, and we treat that as the default case, reproducing existing behaviour.</p>

<p>```</p>

<pre><code>public String getTag(int position) {
    return null;
}
</code></pre>

<p>```</p>

<p>Ok, so now we have a way of getting the tags, let's add an <code>ArrayList&lt;String&gt;</code> member variable to track our fragment tags:</p>

<p>```</p>

<pre><code>private ArrayList&lt;String&gt; mSavedFragmentTags = new ArrayList&lt;String&gt;();
</code></pre>

<p>```</p>

<p>Now we go through and handle this in all 4 places where <code>mSavedState</code> is touched.</p>

<p>In <code>instantiateItem</code> we must find the tag for the newly instantiated fragment first. Once we've got that, if we have saved state we can then compare this new tag with the saved tag. If they match, then we restore the state! If they don't, then we don't restore state. Easy.</p>

<p>```</p>

<pre><code>    Fragment fragment = getItem(position);
    String fragmentTag = getTag(position);
    if (DEBUG) Log.v(TAG, "Adding item #" + position + ": f=" + fragment + " t=" + fragmentTag);
    if (mSavedState.size() &gt; position) {
        String savedTag = mSavedFragmentTags.get(position);
        if (TextUtils.equals(fragmentTag, savedTag)) {
            Fragment.SavedState fss = mSavedState.get(position);
            if (fss != null) {
                fragment.setInitialSavedState(fss);
            }
        }
    }
</code></pre>

<p>```</p>

<p>Note that we also add the fragment using the <a href="https://developer.android.com/reference/android/support/v4/app/FragmentTransaction.html#add(int,"><code>FragmentTransaction#add (int containerViewId, Fragment fragment, String tag)</code></a> signature - that is, we actually use the tag when adding our fragment:</p>

<p>```</p>

<pre><code>    mCurTransaction.add(container.getId(), fragment, fragmentTag);

    return fragment;
}
</code></pre>

<p>```</p>

<p>In <code>destroyItem</code> we just mirror what's done to <code>mSavedState</code>. We pad it out if necessary...</p>

<p>```</p>

<pre><code>    if (DEBUG) Log.v(TAG, "Removing item #" + position + ": f=" + object
            + " v=" + ((Fragment)object).getView() + " t=" + fragment.getTag());
    while (mSavedState.size() &lt;= position) {
        mSavedState.add(null);
        mSavedFragmentTags.add(null);
    }
</code></pre>

<p>```</p>

<p>...then we save the tag at that location.</p>

<p>```</p>

<pre><code>    mSavedState.set(position, mFragmentManager.saveFragmentInstanceState(fragment));
    mSavedFragmentTags.set(position, fragment.getTag());
    mFragments.set(position, null);

    mCurTransaction.remove(fragment);
}
</code></pre>

<p>```</p>

<p>Finally we have the <code>saveState</code> and <code>restoreState</code> methods. These are pretty trival changes. In <code>saveState</code> we put the saved fragment tags into the <code>Bundle</code>:</p>

<p><code>
state.putStringArrayList("tags", mSavedFragmentTags);
</code></p>

<p>And then in <code>restoreState</code>, surprise, we restore the saved fragment tags from the bundle:</p>

<p><code>
mSavedFragmentTags = bundle.getStringArrayList("tags");
</code></p>

<p>Two last things to do:</p>

<ul>
<li>Change your subclass to override your new, fixed, adapter (rather than the one in the support library)</li>
<li>Remember to <strong>override <code>getTag(int position)</code></strong> to return a unique tag for each fragment</li>
</ul>


<p>If you forget either of these things, you'll just have the same behaviour as before. In my <a href="https://github.com/adamsp/FragmentStatePagerIssueExample">demo app</a>, this would look something like the following - obviously you'll need to adjust this to suit your own data source:</p>

<p>```
@Override
public String getTag(int position) {</p>

<pre><code>return labels[position];
</code></pre>

<p>}
```</p>

<p>And that's it! Those're the changes we need to make to the <code>FragmentStatePagerAdapter</code> for it to stop misbehaving and restoring the wrong state to fragments in different locations.</p>

<p>You can find a complete example of this fixed class <a href="https://github.com/adamsp/FragmentStatePagerIssueExample/blob/master/app/src/main/java/com/example/fragmentstatepagerissueexample/app/FixedFragmentStatePagerAdapter.java">in the sample project</a>. There's some lines commented out in the adapter in <code>MainActivity</code>; just swap the class definition and uncomment the method and you've magically got an adapter working as expected!</p>

<h1>That's great! Any gotchas?</h1>

<p>Sure are.</p>

<ul>
<li>Remember to override <code>getTag(int position)</code>, or else you'll continue to see the old behaviour.</li>
<li><code>getTag(int position)</code> must return a <em>unique</em> tag for each fragment.</li>
<li>If your <code>FragmentStatePagerAdapter</code> is an inner class of a <code>Fragment</code>, <em>and</em> you're calling that fragments <code>getTag()</code> method, then that call will now give a compile error. You'll need to change it to <code>MyParentFragment.this.getTag()</code> instead, <em>or</em> change the fixed adapter to use a different method signature - <code>getFragmentTag(int position)</code>, perhaps.</li>
<li>You won't automatically receive bug fixes and updates to the <code>FragmentStatePagerAdapter</code> when the support library updates. This is unlikely to be an issue though - it's been in source for <a href="https://android.googlesource.com/platform/frameworks/support/+log/refs/heads/master/v4/java/android/support/v4/app/FragmentStatePagerAdapter.java">over 18 months as of this writing</a> (Feb 20, 2014) without a single change (the <a href="https://android.googlesource.com/platform/frameworks/support/+log/refs/heads/master/v13/java/android/support/v13/app/FragmentStatePagerAdapter.java">v13 version, too</a>).</li>
<li>If you want to use a different key to put the saved tags into/restore from the bundle (other than just "tags" like I've used here), make sure it doesn't start with "f" - note how a little further down in the <code>restoreState</code> method it checks for keys starting with "f" and assumes they're fragments!</li>
</ul>


<h1>Thanks! You saved the day.</h1>

<p>No worries! Maybe one day you'll write a post on how to fix some obscure bug that I'm having trouble with.</p>

<p>If you have any questions, you can ask me on <a href="https://twitter.com/adamsnz">Twitter</a>, or <a href="https://plus.google.com/+AdamSpeakman">Google+</a>, or open an issue on (or send a pull request to) the <a href="https://github.com/adamsp/FragmentStatePagerIssueExample">Github project</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Broken JSONObject creation from a UTF-8 input String]]></title>
    <link href="http://adamsp.github.com/speakman-website/blog/2013/12/17/broken-jsonobject-creation-from-a-utf-8-input-string/"/>
    <updated>2013-12-17T06:04:00-05:00</updated>
    <id>http://adamsp.github.com/speakman-website/blog/2013/12/17/broken-jsonobject-creation-from-a-utf-8-input-string</id>
    <content type="html"><![CDATA[<blockquote><p>12-16 12:01:40.446: W/System.err(3873): org.json.JSONException: Value ﻿  of type java.lang.String cannot be converted to JSONObject</p></blockquote>

<p>Faced this issue, again, at work today. We have a build system with build variants for different customers. To add a new customer, we just create a new folder, add the images and add a JSON config file to suit the new customers settings. We read from that file and into a JSON string (and then into a JSON object) something like this:</p>

<p><code>
InputStream inStream = context.getResources().openRawResource(R.raw.local_config);
String json = IOUtils.toString(inStream);
JSONObject jsonObject = new JSONObject(json);
</code></p>

<p>Sometimes, new customers speak a language other than English, and we have to save non-ASCII characters. In this case, the file gets saved as UTF-8. Testing this isn't a problem on my devices (Galaxy S2/Nexus 7) - but my tester has twice come back to me now and said that it doesn't work on our 2.3 device.</p>

<!-- more -->


<p>Figuring out the problem this time was pretty quick - I plugged her test phone in, saw this error popping up in Logcat and it triggered my memory about what was wrong. The problem is that the value hidden in that error message (encoded in this case as <code>0xEF 0xBB 0xBF</code>, often showing up as ï»¿ - see the <a href="http://en.wikipedia.org/wiki/Byte_order_mark#Representations_of_byte_order_marks_by_encoding">Wikipedia page</a>) is a Byte Order Mark. This is used to signal the <a href="http://en.wikipedia.org/wiki/Endianness">endianess</a> of the text stream. However, in UTF-8 it probably shouldn't even be there (but is still technically legitimate):</p>

<p><blockquote><p>The Unicode Standard permits the BOM in UTF-8, but does not require nor recommend its use. Byte order has no meaning in UTF-8, so its only use in UTF-8 is to signal at the start that the text stream is encoded in UTF-8.</p><footer><strong>Wikipedia</strong> <cite><a href='http://en.wikipedia.org/wiki/Byte_order_mark#UTF-8'>en.wikipedia.org/wiki/&hellip;</a></cite></footer></blockquote></p>

<p>Because of this, Java doesn't actually support automatically reading the BOM as an indicator of encoding - it adds it as part of the string, so you have to strip it out.  If you don't, automatic parsers such as the one built into JSONObject may freak out and give you a confusing error like the one above. Reading the message, it <em>appears</em> that it can't convert a String, which doesn't make sense, as the constructor takes a String. It's actually referring to the invisible (or in some cases barely visible) BOM character between the words "Value" and "of".</p>

<p>So why is it working correctly on my devices? <a href="https://code.google.com/p/android/issues/detail?id=18508">This bug</a> logged in 2011 was 'fixed' by updating the built in JSON reader to handle UTF-8 strings with or without the Byte Order Mark. This change came in with Ice Cream Sandwich (Android 4.0) - hence why my tester is seeing the problem and I am not.</p>

<p>The fix in our case has been to simply fix the file - the BOM shouldn't be there anyway, so we just remove it. You can do this in Notepad++ by opening the UTF-8 file, clicking the Encoding menu and selecting "Encode in UTF-8 without BOM". This may show up as "ANSI as UTF-8" in the encoding field at the bottom-right.</p>

<p>The other, more general option (if you can't control the source of the JSON you're trying to parse) is to always 'clean' your incoming JSON string. This workaround was suggested in the original bug:</p>

<p>```
public Reader inputStreamToReader(InputStream in) throws IOException {</p>

<pre><code>in.mark(3);
int byte1 = in.read();
int byte2 = in.read();
if (byte1 == 0xFF &amp;&amp; byte2 == 0xFE) {
  return new InputStreamReader(in, "UTF-16LE");
} else if (byte1 == 0xFF &amp;&amp; byte2 == 0xFF) {
  return new InputStreamReader(in, "UTF-16BE");
} else {
  int byte3 = in.read();
  if (byte1 == 0xEF &amp;&amp; byte2 == 0xBB &amp;&amp; byte3 == 0xBF) {
    return new InputStreamReader(in, "UTF-8");
  } else {
    in.reset();
    return new InputStreamReader(in);
  }
}
</code></pre>

<p>}
```</p>

<p>There are also <a href="http://stackoverflow.com/questions/1835430/byte-order-mark-screws-up-file-reading-in-java">many</a>, <a href="http://commons.apache.org/proper/commons-io/apidocs/org/apache/commons/io/input/BOMInputStream.html">many</a> other solutions available.</p>

<p>Wonderful. Note that if you know your file is encoded a certain way, you should <em>always</em> pass the encoding to the reader - never depend on the default charset to be what you need. It's worth spending some time reading about <a href="http://en.wikipedia.org/wiki/Unicode">Unicode</a> and the various encodings you're likely to encounter - <a href="http://en.wikipedia.org/wiki/Windows-1252">Windows-1252 (or CP-1252)</a>, <a href="http://en.wikipedia.org/wiki/UTF-8">UTF-8</a> and <a href="http://en.wikipedia.org/wiki/UTF-16">UTF-16</a>, and how to interpret the bytes for these encodings. I find <a href="http://www.fileformat.info/info/unicode/char/FEFF/index.htm">fileformat.info</a> to be extremely useful, as well as the <a href="http://sourceforge.net/projects/npp-plugins/files/Hex%20Editor/">HexEditor Notepad++ plugin</a> for looking directly at the bytes (which is reportedly a bit unstable with the latest version of NP++, though I've never had any issues) - there will no doubt be something similar either built in to or available for your text editor of choice.</p>

<p>Text encoding problems are painful to deal with - and if you're not sure what you should be using, <a href="http://www.utf8everywhere.org/">use UTF-8</a>.</p>
]]></content>
  </entry>
  
</feed>
