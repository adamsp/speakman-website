<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: open-source | Adam Speakman]]></title>
  <link href="http://adamsp.github.com/speakman-website/blog/categories/open-source/atom.xml" rel="self"/>
  <link href="http://adamsp.github.com/speakman-website/"/>
  <updated>2017-01-24T22:35:24-05:00</updated>
  <id>http://adamsp.github.com/speakman-website/</id>
  <author>
    <name><![CDATA[Adam]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[A bug in (and a fix for) the way FragmentStatePagerAdapter handles fragment restoration]]></title>
    <link href="http://adamsp.github.com/speakman-website/blog/2014/02/20/a-bug-in-and-a-fix-for-the-way-fragmentstatepageradapter-handles-fragment-restoration/"/>
    <updated>2014-02-20T21:25:00-05:00</updated>
    <id>http://adamsp.github.com/speakman-website/blog/2014/02/20/a-bug-in-and-a-fix-for-the-way-fragmentstatepageradapter-handles-fragment-restoration</id>
    <content type="html"><![CDATA[<p>Ever used a <a href="https://developer.android.com/reference/android/support/v4/app/FragmentStatePagerAdapter.html"><code>FragmentStatePagerAdapter</code></a>? We're using one at work for our ticket purchasing wizard. The user enters the wizard, and can progress to the next page once they've completed the current one. We control this by manipulating the stack of pages and notifying the adapter that the data has changed when a new page is available.</p>

<p>Unfortunately, when changing pages that have already been loaded, there's an unexpected bug. Specifically, when you load a page, remove it and then insert a new one in its place, the next time the fragment at that index is loaded, it receives the <code>savedInstanceState</code> bundle for the <em>old</em> fragment.</p>

<!-- more -->


<h1>How'd you find <em>that</em>?</h1>

<p>The specific use case where I discovered this was the case where a customer is purchasing tickets to a film, and they change their mind about which type of tickets they want.</p>

<p>First, the customer selects tickets that require manually selected seats. We save the tickets, receive the seating data, and send the customer to the next page where they can select from a seat in a map.</p>

<p>If the customer changes their mind at this stage and returns to the previous page, as soon as they make a change to their selected tickets we consider all future pages invalid. We 'remove' the seat selection fragment and notify the adapter. If the customer has now selected tickets that <em>don't</em> require manual seat selection (that is, they've chosen tickets for an unallocated seating area), we save the tickets, receive empty seating data, and know to send them on to the "details" page where they can enter in their name and email.</p>

<p>This is where the process breaks down. Since the two fragments are different (one's called <code>SeatingFragment</code> and the other is <code>CustomerDetailsFragment</code>, say), I wasn't expecting to receive any saved instance state on the first load of the new fragment - however I was getting state passed in! This caused a crash, as I was depending on the state being null to assume first-load.</p>

<p>The state I was seeing was the state for the previously loaded fragment at that index. That is, when the <code>CustomerDetailsFragment</code> in the example scenario was loaded (replacing the <code>SeatingFragment</code>), it was receiving the saved state bundle for the <code>SeatingFragment</code>, when it should've been receiving no saved state bundle at all.</p>

<h1>Can you reproduce it?</h1>

<p>I've written a <a href="https://github.com/adamsp/FragmentStatePagerIssueExample">very simple example app</a> which shows this behaviour. If you swipe backwards and forwards you can see the fragments labeled "1", "2", "3", colored Red, Yellow and Green. Now, press the 'Switch Fragment' button. You'll be sent back to index 0 (fragment "1"). This forces the removal of fragment "3", which gets its state saved. But we've changed the content of the adapter - so next time you load fragment "3", you'll see that its color has changed to Blue. <strong>This is a different fragment</strong>, but it's label has been restored from the previous fragments saved state! If you rotate your device, or simply swipe back to the first view and then back to the third again, you'll see the correct label of "4" (it saves the state fresh when it removes it, resulting in the correct saved state next time it's loaded).</p>

<h1>Why does this occur?</h1>

<p>If we take a look at the source code <a href="https://android.googlesource.com/platform/frameworks/support/+/6d6186b9a2503200844febe1b8ba083206c7cbcd/v4/java/android/support/v4/app/FragmentStatePagerAdapter.java">as of this writing</a>, we can see that the <code>FragmentStatePagerAdapter</code> stores a list of states:</p>

<p><code>
private ArrayList&lt;Fragment.SavedState&gt; mSavedState = new ArrayList&lt;Fragment.SavedState&gt;();
</code></p>

<p>Looking through the code we can see that this array is used in four places. It's used in <code>instantiateItem</code>, <code>destroyItem</code>, <code>saveState</code> and <code>restoreState</code>.  We can ignore <code>saveState</code> and <code>restoreState</code> for now, as they're just saving the adapters overall state into an external bundle, and then loading it back up.</p>

<p>First, let's take a look at what's going on in <code>destroyItem</code>. When a fragment is due to be destroyed, this method first starts a transaction (if one isn't already started), then pads out the <code>mSavedState</code> array with null entries until it's at least the size of the index of the fragment we're removing.</p>

<p>```</p>

<pre><code>@Override
public void destroyItem(ViewGroup container, int position, Object object) {
    Fragment fragment = (Fragment)object;

    if (mCurTransaction == null) {
        mCurTransaction = mFragmentManager.beginTransaction();
    }
    if (DEBUG) Log.v(TAG, "Removing item #" + position + ": f=" + object
            + " v=" + ((Fragment)object).getView());
    while (mSavedState.size() &lt;= position) {
        mSavedState.add(null);
    }
</code></pre>

<p>```</p>

<p>Nothing too exciting there. It then saves the state of the fragment that is being removed into the corresponding index in the <code>mSavedState</code> list, and removes the fragment:</p>

<p>```</p>

<pre><code>    mSavedState.set(position, mFragmentManager.saveFragmentInstanceState(fragment));
    mFragments.set(position, null);

    mCurTransaction.remove(fragment);
}
</code></pre>

<p>```</p>

<p>Now let's see what happens in the other direction - instantiating an item. First thing to do is check and see if we already have a <code>Fragment</code> object created and stored at the given position. Short-circuit back out with this if we do:</p>

<p>```</p>

<pre><code>@Override
public Object instantiateItem(ViewGroup container, int position) {
    // If we already have this item instantiated, there is nothing
    // to do.  This can happen when we are restoring the entire pager
    // from its saved state, where the fragment manager has already
    // taken care of restoring the fragments we previously had instantiated.
    if (mFragments.size() &gt; position) {
        Fragment f = mFragments.get(position);
        if (f != null) {
            return f;
        }
    }
</code></pre>

<p>```</p>

<p>If however we <em>don't</em> have a fragment there, we have to create one. This could be because we've never seen this page of the <code>ViewPager</code> before, or it could be because the page was removed due to the left/right limits (recall a <code>ViewPager</code> will only keep the first page to the left and right of the current one, by default).</p>

<p>```</p>

<pre><code>    if (mCurTransaction == null) {
        mCurTransaction = mFragmentManager.beginTransaction();
    }

    Fragment fragment = getItem(position);
    if (DEBUG) Log.v(TAG, "Adding item #" + position + ": f=" + fragment);
</code></pre>

<p>```</p>

<p>Now, here's the important part. After we've asked our concrete subclass to create/instantiate a fragment for us (through the <code>getItem(position)</code> call), we check to see if we have any saved state <em>at that position</em>. There's the crucial part - we're <strong>checking for saved state based on the fragments index in an array, rather than on some unique property of the fragment</strong>.</p>

<p>```</p>

<pre><code>    if (mSavedState.size() &gt; position) {
        Fragment.SavedState fss = mSavedState.get(position);
        if (fss != null) {
            fragment.setInitialSavedState(fss);
        }
    }
</code></pre>

<p>```</p>

<p>The issue with this is that the fragment at that position may no longer be the same fragment as was there last time we displayed the page at this position! So that saved state bundle may no longer be the correct one.</p>

<p>Finally, we add the fragment to our list of fragments and display it:</p>

<p>```</p>

<pre><code>    while (mFragments.size() &lt;= position) {
        mFragments.add(null);
    }
    fragment.setMenuVisibility(false);
    fragment.setUserVisibleHint(false);
    mFragments.set(position, fragment);
    mCurTransaction.add(container.getId(), fragment);

    return fragment;
}
</code></pre>

<p>```</p>

<h1>Fixes or workarounds?</h1>

<p>Luckily, there's a way around this problem! Hurrah!</p>

<p>We simply need some way of identifying the fragments, and comparing whether this identifying value is the same or not when we try to restore state to a freshly instantiated fragment. The best way to do this is to ask our concrete subclass for an identifier for this fragment - a tag.</p>

<p>So, let's copy the <a href="https://android.googlesource.com/platform/frameworks/support/+/master/v4/java/android/support/v4/app/FragmentStatePagerAdapter.java">entire source of <code>FragmentStatePagerAdapter</code></a> and get started. First thing to do is add a way of getting tags from our subclasses. Since we don't want to break existing implementations that don't actually care about swapping out fragments, we won't make this method abstract. Instead it'll just <code>return null;</code> by default, and we treat that as the default case, reproducing existing behaviour.</p>

<p>```</p>

<pre><code>public String getTag(int position) {
    return null;
}
</code></pre>

<p>```</p>

<p>Ok, so now we have a way of getting the tags, let's add an <code>ArrayList&lt;String&gt;</code> member variable to track our fragment tags:</p>

<p>```</p>

<pre><code>private ArrayList&lt;String&gt; mSavedFragmentTags = new ArrayList&lt;String&gt;();
</code></pre>

<p>```</p>

<p>Now we go through and handle this in all 4 places where <code>mSavedState</code> is touched.</p>

<p>In <code>instantiateItem</code> we must find the tag for the newly instantiated fragment first. Once we've got that, if we have saved state we can then compare this new tag with the saved tag. If they match, then we restore the state! If they don't, then we don't restore state. Easy.</p>

<p>```</p>

<pre><code>    Fragment fragment = getItem(position);
    String fragmentTag = getTag(position);
    if (DEBUG) Log.v(TAG, "Adding item #" + position + ": f=" + fragment + " t=" + fragmentTag);
    if (mSavedState.size() &gt; position) {
        String savedTag = mSavedFragmentTags.get(position);
        if (TextUtils.equals(fragmentTag, savedTag)) {
            Fragment.SavedState fss = mSavedState.get(position);
            if (fss != null) {
                fragment.setInitialSavedState(fss);
            }
        }
    }
</code></pre>

<p>```</p>

<p>Note that we also add the fragment using the <a href="https://developer.android.com/reference/android/support/v4/app/FragmentTransaction.html#add(int,"><code>FragmentTransaction#add (int containerViewId, Fragment fragment, String tag)</code></a> signature - that is, we actually use the tag when adding our fragment:</p>

<p>```</p>

<pre><code>    mCurTransaction.add(container.getId(), fragment, fragmentTag);

    return fragment;
}
</code></pre>

<p>```</p>

<p>In <code>destroyItem</code> we just mirror what's done to <code>mSavedState</code>. We pad it out if necessary...</p>

<p>```</p>

<pre><code>    if (DEBUG) Log.v(TAG, "Removing item #" + position + ": f=" + object
            + " v=" + ((Fragment)object).getView() + " t=" + fragment.getTag());
    while (mSavedState.size() &lt;= position) {
        mSavedState.add(null);
        mSavedFragmentTags.add(null);
    }
</code></pre>

<p>```</p>

<p>...then we save the tag at that location.</p>

<p>```</p>

<pre><code>    mSavedState.set(position, mFragmentManager.saveFragmentInstanceState(fragment));
    mSavedFragmentTags.set(position, fragment.getTag());
    mFragments.set(position, null);

    mCurTransaction.remove(fragment);
}
</code></pre>

<p>```</p>

<p>Finally we have the <code>saveState</code> and <code>restoreState</code> methods. These are pretty trival changes. In <code>saveState</code> we put the saved fragment tags into the <code>Bundle</code>:</p>

<p><code>
state.putStringArrayList("tags", mSavedFragmentTags);
</code></p>

<p>And then in <code>restoreState</code>, surprise, we restore the saved fragment tags from the bundle:</p>

<p><code>
mSavedFragmentTags = bundle.getStringArrayList("tags");
</code></p>

<p>Two last things to do:</p>

<ul>
<li>Change your subclass to override your new, fixed, adapter (rather than the one in the support library)</li>
<li>Remember to <strong>override <code>getTag(int position)</code></strong> to return a unique tag for each fragment</li>
</ul>


<p>If you forget either of these things, you'll just have the same behaviour as before. In my <a href="https://github.com/adamsp/FragmentStatePagerIssueExample">demo app</a>, this would look something like the following - obviously you'll need to adjust this to suit your own data source:</p>

<p>```
@Override
public String getTag(int position) {</p>

<pre><code>return labels[position];
</code></pre>

<p>}
```</p>

<p>And that's it! Those're the changes we need to make to the <code>FragmentStatePagerAdapter</code> for it to stop misbehaving and restoring the wrong state to fragments in different locations.</p>

<p>You can find a complete example of this fixed class <a href="https://github.com/adamsp/FragmentStatePagerIssueExample/blob/master/app/src/main/java/com/example/fragmentstatepagerissueexample/app/FixedFragmentStatePagerAdapter.java">in the sample project</a>. There's some lines commented out in the adapter in <code>MainActivity</code>; just swap the class definition and uncomment the method and you've magically got an adapter working as expected!</p>

<h1>That's great! Any gotchas?</h1>

<p>Sure are.</p>

<ul>
<li>Remember to override <code>getTag(int position)</code>, or else you'll continue to see the old behaviour.</li>
<li><code>getTag(int position)</code> must return a <em>unique</em> tag for each fragment.</li>
<li>If your <code>FragmentStatePagerAdapter</code> is an inner class of a <code>Fragment</code>, <em>and</em> you're calling that fragments <code>getTag()</code> method, then that call will now give a compile error. You'll need to change it to <code>MyParentFragment.this.getTag()</code> instead, <em>or</em> change the fixed adapter to use a different method signature - <code>getFragmentTag(int position)</code>, perhaps.</li>
<li>You won't automatically receive bug fixes and updates to the <code>FragmentStatePagerAdapter</code> when the support library updates. This is unlikely to be an issue though - it's been in source for <a href="https://android.googlesource.com/platform/frameworks/support/+log/refs/heads/master/v4/java/android/support/v4/app/FragmentStatePagerAdapter.java">over 18 months as of this writing</a> (Feb 20, 2014) without a single change (the <a href="https://android.googlesource.com/platform/frameworks/support/+log/refs/heads/master/v13/java/android/support/v13/app/FragmentStatePagerAdapter.java">v13 version, too</a>).</li>
<li>If you want to use a different key to put the saved tags into/restore from the bundle (other than just "tags" like I've used here), make sure it doesn't start with "f" - note how a little further down in the <code>restoreState</code> method it checks for keys starting with "f" and assumes they're fragments!</li>
</ul>


<h1>Thanks! You saved the day.</h1>

<p>No worries! Maybe one day you'll write a post on how to fix some obscure bug that I'm having trouble with.</p>

<p>If you have any questions, you can ask me on <a href="https://twitter.com/adamsnz">Twitter</a>, or <a href="https://plus.google.com/+AdamSpeakman">Google+</a>, or open an issue on (or send a pull request to) the <a href="https://github.com/adamsp/FragmentStatePagerIssueExample">Github project</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Open Source licenses page]]></title>
    <link href="http://adamsp.github.com/speakman-website/blog/2013/09/24/android-open-source-licenses-page/"/>
    <updated>2013-09-24T20:49:00-04:00</updated>
    <id>http://adamsp.github.com/speakman-website/blog/2013/09/24/android-open-source-licenses-page</id>
    <content type="html"><![CDATA[<p>Ever used an open source library in your Android app? If you have, then you <a href="http://www.tldrlegal.com/browse">probably</a> should have included a page with the license details for that library. If you did, great! You probably had the same question I did recently; how should you do that?</p>

<!-- more -->


<p>My first attempt looked like this - in fact, this is currently what my '<a href="https://github.com/adamsp/wookmark">Wookmark Viewer</a>' licenses page looks like:</p>

<p><a href="/images/android-licenses-page/wookmark_licenses.png"><img src="/images/android-licenses-page/wookmark_licenses.png" width="240" height="400" title="Wookmark Licenses" ></a></p>

<p>However, while this page details the libraries used and their licenses, and provides links to those things, it isn't good enough. It says in the <a href="http://www.apache.org/licenses/LICENSE-2.0.html">Apache License, Version 2.0</a>:</p>

<p><blockquote><p>You must give any other recipients of the Work or Derivative Works a copy of this License.</p></blockquote></p>

<p>So how should I do that? Do I have to include the same license multiple times for different libraries that use the same license? How do I include that in a regular old TextView?</p>

<p>I revisited these issues at work recently when I was tasked with adding the licenses page to our app. After some time looking around online, I couldn't really find any suggestions as to how this page should behave, how it should look, or how to display licenses for multiple libraries. The only thing I found was <a href="http://stackoverflow.com/questions/11300552/license-screen-about-phone-legal-information-open-licenses-screen">this Stack Overflow question</a>, but that was enough of a lead to set me on the right path. I checked out some of the other Google apps - see the Play Music and Gmail apps licenses pages below. This is simply an HTML page displayed in a DialogFragment. This is more like it!</p>

<p><a href="/images/android-licenses-page/play_music_licenses.png"><img src="/images/android-licenses-page/play_music_licenses.png" width="240" height="400" title="Play Music Licenses" ></a><a href="/images/android-licenses-page/gmail_licenses.png"><img src="/images/android-licenses-page/gmail_licenses.png" width="240" height="400" title="Gmail Licenses" ></a></p>

<p>This answers the questions of how to display things nicely (including the full license text), how to handle multiple libraries with the same license, how to display any copyright notice, and how to link to any modified source code, as required in the <a href="http://opensource.org/licenses/gpl-2.0.php">GPL-2.0</a> license, for example. It should also be simple enough to set up to automatically construct this page (or a similar one) in your build scripts - including any custom text you may want to add, as I've done above for my original attempt on the Wookmark app.</p>

<p>I've created a DialogFragment that reproduces the Google apps licenses page experience - <a href="https://github.com/adamsp/AndroidLicensesPage">AndroidLicensesPage on Github</a>.</p>

<p>If you want to use this fragment in your application, you need to include <code>LicensesFragment.java</code> in your projects source, as well as including the <code>licenses_fragment.xml</code> layout file in <code>/res/layout</code> and the <code>licenses.html</code> file in <code>/res/raw</code>. You should update the namespace to suit.</p>

<p>To display licenses for your app, you need to update the <code>licenses.html</code> file to suit (including any libraries you've used, their licenses, copyrights, and any links to source you may have modified, if required), then you can display it as you would any other <a href="http://developer.android.com/reference/android/app/DialogFragment.html">DialogFragment</a>:</p>

<p>```
// Create &amp; show a licenses fragment just as you would any other DialogFragment.
FragmentTransaction ft = getSupportFragmentManager().beginTransaction();
Fragment prev = getSupportFragmentManager().findFragmentByTag("licensesDialogFragment");
if (prev != null) {</p>

<pre><code>ft.remove(prev);
</code></pre>

<p>}
ft.addToBackStack(null);</p>

<p>// Create and show the dialog.
DialogFragment newFragment = LicensesFragment.newInstance();
newFragment.show(ft, "licensesDialogFragment");
```</p>

<p>There are some TODOs in the LicensesFragment file - you should modify these things to suit your environment, though things will work fine without you needing to touch anything.</p>

<p>If you want to see an example of this in action, clone the repository and you should be able to open the included AndroidLicensesPageExampleProject in Android Studio. It should run directly on any device or emulator running Android 2.1 or higher.</p>
]]></content>
  </entry>
  
</feed>
